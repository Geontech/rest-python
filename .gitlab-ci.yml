# This CI script builds Docker-REDHAWK's webserver image and deploys it to
# dockerhub upon successful execution of its tests.
variables:
  CONTAINER_TEST_IMAGE:    $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  CONTAINER_RELEASE_IMAGE: $CI_REGISTRY_IMAGE:latest
  DOCKERHUB_IMAGE:         geontech/redhawk-webserver

stages:
  - build
  - test
  - release
  - deploy
  - cleanup

.dind: &dind
  image: docker:latest

.container_registry: &container_registry
  <<: *dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  after_script:
    - docker logout $CI_REGISTRY

# Build the test image and push it to the registry, delete the runner-local
# image to avoid cluttering the runner.
build:
  stage: build
  except:
    - tags
  <<: *container_registry
  script:
    - sed -i -E "s/(geontech.+\:)(.+)/\1"$REDHAWK_VERSION"/g" Dockerfile
    - docker build
      --pull
      --tag $CONTAINER_TEST_IMAGE .
    - docker push $CONTAINER_TEST_IMAGE
    - docker rmi $CONTAINER_TEST_IMAGE

test:
  stage: test
  <<: *container_registry
  except:
    - tags
  script:
    # Install docker-compose
    - apk add --no-cache py2-pip && pip install docker-compose

    # Pull the test image and start the stack without rebuilding it.
    - cd tests
    - docker pull ${CONTAINER_TEST_IMAGE}
    - docker-compose -p ${CI_COMMIT_SHA} up -d --no-build
    - docker-compose -p ${CI_COMMIT_SHA} exec -T rest
      bash -l -c 'yum install -y rh.SigGen rh.FileWriter'
    - docker-compose -p ${CI_COMMIT_SHA} exec -T rest
      bash -l -c './test.sh' || RESULT=$?

    # Clean up and exit with the result
    - docker-compose -p ${CI_COMMIT_SHA} down
    - docker rmi ${CONTAINER_TEST_IMAGE}
    - exit ${RESULT}

# Move the test image to internal 'latest' and clean up the worker's images
release:
  stage: release
  only:
    - master
  except:
    - tags
  <<: *container_registry
  script:
    - docker pull $CONTAINER_TEST_IMAGE
    - docker tag $CONTAINER_TEST_IMAGE $CONTAINER_RELEASE_IMAGE
    - docker push $CONTAINER_RELEASE_IMAGE
    - docker rmi $CONTAINER_TEST_IMAGE $CONTAINER_RELEASE_IMAGE

# Clean up the test image from the internal registry.
cleanup-ci:
  stage: cleanup
  when: always
  except:
    - master
    - tags
  <<: *container_registry
  script:
    - apk add --no-cache git bash curl
    - git clone ${DOCKER_UTILS} docker-util
    - docker-util/delete-image.sh $CONTAINER_TEST_IMAGE

# Push the released image to DockerHub on tags
deploy-image:
  stage: deploy
  only:
    - tags
  <<: *container_registry
  variables:
    dockerhub_image_tag:    geontech/redhawk-webserver:$CI_COMMIT_TAG
    dockerhub_image_latest: geontech/redhawk-webserver:latest
  script:
    # Use JQ to patch in our dockerhub credentials for the public push
    - apk add --no-cache jq
    - >
      jq --arg token "$DOCKERHUB_TOKEN" 
        '.auths["https://index.docker.io/v1"] = { auth: $token }'
        ~/.docker/config.json > ~/.docker/config.json
    # Pull the release image, re-tag it to the dockerhub name and push it.
    - docker pull $CONTAINER_RELEASE_IMAGE
    - docker tag $CONTAINER_RELEASE_IMAGE ${dockerhub_image_tag}
    - docker tag $CONTAINER_RELEASE_IMAGE ${dockerhub_image_latest}
    - docker push ${dockerhub_image_tag} ${dockerhub_image_latest}
    - docker rmi ${CONTAINER_RELEASE_IMAGE} ${dockerhub_image_tag} ${dockerhub_image_latest}

# Push to GitHub
deploy-github:
  stage: deploy
  only:
    - tags
  image: alpine:latest
  script:
    - apk add --no-cache openssh-client git
    - eval $(ssh-agent -s)
    - echo "${GITHUB_TOKEN}" | ssh-add - 
    - mkdir -p ~/.ssh
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config
    # Reconfigure git and push w/ tag(s)
    - git config user.name "${GITHUB_USER_NAME}"
    - git config user.email "${GITHUB_USER_EMAIL}"
    - git remote set-url origin ${GITHUB_REPO}
    - git push origin ${GITHUB_BRANCH} --follow-tags
